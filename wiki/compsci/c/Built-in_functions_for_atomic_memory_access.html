<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

		<link rel="stylesheet" href="/css/style.css" type="text/css" media="screen" charset="utf-8" />

		<link rel="shortcut icon" href="/images/favicon.ico" />

		<title>Home</title>
	</head>

	<body>
		<header>
			wiredspace.de
			<nav>
				<ul id="navigation-list">
					<li><a href="/index.html">Home</a></li>
					<li><a href="/wiki/wiki.html">Wiki</a></li>
					<li><a href="https://bin.wiredspace.de/">PrivateBin</a></li>
					<li><a href="/about.html">About</a></li>
				</ul>
			</nav>
		</header>
		<main>
			<h1>
				<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html">Built-in functions for atomic memory access</a>
			</h1>

			<p>
				Using a semaphore requires an atomic operation, so that a deadlock cannot occur. The <strong>Intel Itanium Processor-specific Application Binary Interface</strong> specifies some built-ins that are atomic operations&#8230;
				There are built-ins for a few functionalities, but these are the most imporant:
			</p>

			<ul>
				<li>add, sub, or, and, xor, nand</li>
				<li>compare and swap</li>
			</ul>

			<p>The first of the two can be called in <strong>gcc</strong> by using the following built-in functions:</p>

			<ul>
				<li>
					Type 1:

					<ul>
						<li><code>type __sync_fetch_and_add(type *ptr, type value, ...)</code></li>
						<li><code>type __sync_fetch_and_sub (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_fetch_and_or (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_fetch_and_and (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_fetch_and_xor (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_fetch_and_nand (type *ptr, type value, ...)</code></li>
					</ul>
				</li>
				<li>
					Type 2:

					<ul>
						<li><code>type __sync_add_and_fetch (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_sub_and_fetch (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_or_and_fetch (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_and_and_fetch (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_xor_and_fetch (type *ptr, type value, ...)</code></li>
						<li><code>type __sync_nand_and_fetch (type *ptr, type value, ...)</code></li>
					</ul>
				</li>
			</ul>

			<p>Type 1 and 2 are only different in the sense, that Type 1 returns the value that had previously been in memory, and Type 2 returns the new value.</p>

			<p>The second of the two are atomic operations for comparing and swapping</p>

			<ul>
				<li>
					Type 1:

					<ul>
						<li><code>bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</code></li>
					</ul>
				</li>
				<li>
					Type 2:

					<ul>
						<li><code>type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...)</code></li>
					</ul>
				</li>
			</ul>

			<p>These functions take 3 arguments:</p>

			<ul>
				<li>a pointer <code>ptr</code> to the value that needs changing</li>
				<li>a value <code>oldval</code> which is the value before the swap</li>
				<li>and a value <code>newval</code> which is the new value after swapping</li>
			</ul>

			<p>
				These functions compare the current value of <code>ptr</code> to <code>oldval</code> and if they are the same, <code>newval</code> is being written to <code>ptr</code>&#8230; The two types are different in the way that the
				first type returns a <code>bool</code> if the comparison is successful and <code>newval</code> is written into <code>ptr</code> and the second type returns the content of <code>ptr</code> before the operation.
			</p>
		</main>
		<footer>
			<a href="/privacy.html">Privacy Policy</a>
		</footer>
	</body>
</html>
